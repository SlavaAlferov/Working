"""
С клавиатуры поступает строка, которая имеет только символы: '(', ')', '{', '3', '[' и ']'.
Необходимо проверить правильно ли сформированы скобки.
Если ВСЕ скобки сформированы правильно, то вывести True, если нет, то вывести самую длинную правильно сформированную подстроку скобок, если такой подстроки нету, то вывести False.
(Сначала лучше сделать True и False, а потом работать с подстроками).
    Input: "()[]{}"
    Output: True
    Input: "(]"
    Output: False
    Input: ")()())"
    Output: "()()"
    Input: "{[()]{[()]}}"
    Output: True
    Input: "{[(]){[()]}}"
    Output: "{[()]}"
"""

def valid(s):
    """Проверяет, является ли вся строка скобок валидной"""
    stack = []  # Стек для отслеживания открывающих скобок
    brackets = {')': '(', '}': '{', ']': '['}  # Соответствие закрывающих и открывающих скобок

    for char in s:
        if char in brackets.values():  # Если символ - открывающая скобка
            stack.append(char)  # Добавляем в стек
        elif char in brackets:  # Если символ - закрывающая скобка
            if not stack or stack.pop() != brackets[char]:  # Если стек пуст или скобки не совпадают
                return False  # Строка невалидна
    return not stack  # Если стек пуст - все скобки закрыты правильно

def long(s):
    """Находит самую длинную валидную подстроку скобок"""
    max_len = 0  # Максимальная длина валидной подстроки
    max_str = ""  # Самая длинная валидная подстрока
    stack = [-1]  # Стек индексов, начинаем с -1 для правильного расчета длины

    for i, char in enumerate(s):  # Перебираем все символы с их индексами
        if char in '({[':  # Если открывающая скобка
            stack.append(i)  # Добавляем индекс в стек
        else:  # Если закрывающая скобка
            if stack:  # Если стек не пустой
                stack.pop()  # Удаляем последний индекс
            if not stack:  # Если стек стал пустым
                stack.append(i)  # Добавляем текущий индекс как новую базовую точку
            else:  # Если в стеке есть элементы
                # Вычисляем длину текущей валидной последовательности
                current_len = i - stack[-1]
                if current_len > max_len:  # Если нашли более длинную валидную подстроку
                    max_len = current_len
                    max_str = s[stack[-1] + 1:i + 1]  # Запоминаем подстроку

    return max_str if max_len > 0 else False  # Возвращаем подстроку или False


def main():
    s = input()

    if valid(s):  # Проверяем всю строку
        print(True)  # Если валидна - выводим True
    else:
        result = long(s)  # Иначе ищем самую длинную валидную подстроку
        print(result if result else False)  # Выводим подстроку или False


if __name__ == '__main__':
    main()
